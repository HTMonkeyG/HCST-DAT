# 2.2 正选、反选与逆选
&emsp;&emsp;正选、反选与逆选是选择器的不同类型与关系。

## 2.2.1 正选与反选
&emsp;&emsp;正选是选择器最基础的类型。每一个独立的选择器都是其本身的正选。

&emsp;&emsp;一个选择器的反选是另一个选择结果为前者的补集的选择器：$`S_i(a) = \complement_{@e} S(a)`$，也可使用`unless entity`子命令达到相同效果。

## 2.2.2 逆选
&emsp;&emsp;逆选旧称选择器方程。一个选择器的逆选是另一个结果为使用前者进行选择时可以选中另一些指定实体的实体的选择器。

&emsp;&emsp;上面的表述看上去很绕，使用选择器函数进行的表述是这样的：
```math
S^{-1}(B) = \left \{ x \in A \mid S(x) \cap B \neq \varnothing \right \}，
```
其中$`A`$为备选实体集，$`B`$为指定实体集，$`S`$为原始选择器。$`A`$与$`B`$均需要为执行者无关筛选器。

&emsp;&emsp;逆选在某种程度上可以看作选择器函数的逆映射，但是这样并不严谨。

## 2.2.3 逆选通解
&emsp;&emsp;绝大多数逆选问题在旧版中是无法（通过不显式使用遍历的方法）求解的，而在新语法中，可以通过一些取巧的办法在大多数情况下求解。

&emsp;&emsp;先假设我们要求解的逆选中的选择器没有``c=k``等按距离排序的操作以及``@r``。那么，这样的选择器的正选可以看作分别筛选出选择器每个参数对应的实体集，而后对它们统一求交集的结果。因此该类型的逆选仅需一个判定：
```
execute as <A> at @s if entity <S> ...
```
&emsp;&emsp;其中S为原始选择器与指定实体集的交集，即简单地将参数合并在一起。后续未被截断的分支便为逆选结果。

**例 2.2.3-1**&emsp;选择半径100格内存在苦力怕的创造模式玩家：

**解**&emsp;备选实体集$`A=`$@e[m=c]，指定实体集$`B=`$`@e[type=creeper]`，原始选择器$`S=`$`@e[r=100]`。代入上述指令得：
```
execute as @e[m=c] at @s if entity @e[type=creeper,r=100] ...
```
&emsp;&emsp;在区分原始选择器与指定实体集时尤其需要注意：上述问题中的原始选择器并非`@e[type=creeper,r=100]`。如果区分出错，虽然对于无`c=k`操作的逆选并无大碍，但是有`c=k`操作的逆选将会无法求解。

&emsp;&emsp;对于存在`c=k`操作的选择器，因为按距离排序选择的操作较为特殊：该操作事实上是在其他参数执行完成后再对结果进行排序，因此通解较为复杂：
```
execute as <A> at @s as <S> if entity @s[<B>] as @e[r=0.25,c=1] at @s ...
```
&emsp;&emsp;另一种不改变执行者的可行解法如下：
```
execute as <A> at @s at <S> if entity @e[r=0.25,c=1,<B>] at @s ...
```
&emsp;&emsp;其中A为备选实体集，B为指定实体集对应选择器的参数，S为原始选择器。

&emsp;&emsp;对于上述两种解法，原理都是先使用原始选择器选出一个实体，再判定该实体是否属于指定实体集，最后通过位置实体层或者执行者等不变量将执行者改回该实体。不直接合并参数是由于合并后`c=k`操作后于所有其余操作执行导致结果出错。

&emsp;&emsp;不难看出，第一种解法是后两种解法退化的结果。

**例 2.2.3-2**&emsp;选择距离最近的玩家是HTMonkeyG的蝙蝠：

**解**&emsp;备选实体集$`A=`$`@e[type=bat]`，指定实体集$`B=`$`@a[name=HTMonkeyG]`，原始选择器$`S=`$`@p`。代入上述指令得：
```
execute as @e[type=bat] at @s as @p if entity @s[name=HTMonkeyG] as @e[r=0.25,c=1] at @s ...
```